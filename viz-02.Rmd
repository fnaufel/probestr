--- 
knit: "bookdown::render_book"
---

# Visualização com ggplot2 (continuação) {#viz2}

::: {.rmdtip latex=1}

Busque mais informações sobre os pacotes `tidyverse` e `ggplot2` [nas referências recomendadas](#refrec).

:::


## Vídeo 1

```{r echo=FALSE, results='asis', out.extra=center()}
embed_yt('TjgLDeIQHIc')
```


## *Boxplots*

### Conjunto de dados

* Vamos continuar a trabalhar com os dados sobre as horas de sono de alguns mamíferos:

  ```{r}
  sono <- msleep %>% 
    select(name, vore, order, sleep_total)
    
  sono
  ```


### Mediana e quartis

* Para entender *boxplots*, precisamos, antes, entender algumas medidas.

* Se tomarmos as quantidades de horas de sono de todos os animais do conjunto de dados e [classificarmos estas quantidades em ordem crescente]{.hl}, vamos ter:

  ```{r}
  horas <- sono %>% 
    pull(sleep_total) %>% 
    sort()
  
  horas
  ```

* Quantos valores são?

  ```{r}
  length(horas)
  ```

* O valor que está [bem no meio desta fila]{.hl} --- i.e., na posição $`r ceiling(length(horas) / 2)`$ --- é a [mediana]{.hl}:

  ```{r}
  horas[ceiling(length(horas) / 2)]
  ```

* Em R:

  ```{r}
  median(horas)
  ```

  ::: {.rmdcaution latex=1}
  
  Mediana e média são coisas muito diferentes.
  
  Por acaso, neste exemplo, a média das horas é próxima da mediana:

  ```{r}
  mean(horas)
  ```

  Isto costuma acontecer quando a distribuição dos dados é aproximadamente simétrica.

  :::

* Os [quartis]{.hl} são os valores que estão nas posições $\frac14$, $\frac12$ e $\frac34$ da fila. São o [primeiro, segundo e terceiro quartis]{.hl}, respectivamente.

  ```{r}
  horas[
    c(
      ceiling(length(horas) / 4),
      ceiling(length(horas) / 2),
      ceiling(3 * length(horas) / 4)
    )
  ]
  ```

* [Sim, a mediana é o segundo quartil.]{.hl}

* Em R, a [função `quantile`]{.hl} generaliza esta idéia: dado um número $q$ entre $0$ e $1$, [o quantil (com "N") $q$ é o elemento que está na posição que corresponde à fração $q$ da fila ordenada.]{.hl}

  ```{r}
  horas %>% quantile(c(.25, .5, .75))
  ```

* Na verdade, R tem $9$ algoritmos diferentes para calcular os quantis de uma amostra! Leia a ajuda da função `quantile` para conhecê-los.

* As diferenças entre nossos cálculos "à mão" e os resultados retornados por `quantile` são porque, em algumas situações, `quantile` calcula uma média ponderada entre elementos vizinhos. Por isso, `quantile` pode retornar valores que nem estão no vetor.

* Em R, a [função `summary`]{.hl} mostra o [mínimo]{.hl}, os [quartis (com "R")]{.hl}, a [média]{.hl}, e o [máximo]{.hl} de um vetor:

  ```{r}
  summary(horas)
  ```


### Média $\times$ mediana

* Vamos ver um exemplo simples para entender a diferença entre a média e a mediana.

* Imagine o seguinte vetor com as receitas mensais de algumas pessoas (em milhares de reais:)

  ```{r}
  receitas <- c(1, 2, 2, 3.5, 1, 4, 1)
  ```

* Eis a mediana e a média deste vetor:

  ```{r}
  summary(receitas)[c('Median', 'Mean')]
  ```

* A mediana e a média são bem próximas.

* Imagine, agora, que adicionamos ao vetor um sujeito com receita mensal de $100$ mil reais:

  ```{r}
  receitas <- c(1, 2, 2, 3.5, 1, 4, 1, 100)
  ```

* Eis a nova mediana e a nova média:

  ```{r}
  summary(receitas)[c('Median', 'Mean')]
  ```

* O sujeito com a receita de $`r median(receitas)`$ mil reais continua no meio da fila, mas a média (que é a soma de todas as receitas, dividida pelo número de indivíduos) ficou muito diferente.

* A receita do novo sujeito é um [valor discrepante]{.hl}, ou, em inglês, um [*outlier*]{.hl}.

::: {.rmdimportant latex=1}

**Conclusão:** 

A [mediana é robusta]{.hl}, pouco afetada por *outliers*.

A [média é pouco robusta]{.hl}, muito sensível a *outliers*.

:::


### Intervalo interquartil (IQR) e *outliers*

* Qual fração dos elementos está [entre o primeiro e o terceiro quartis?]{.hl}

  ```{r}
  length(
    horas[between(horas, quantile(horas, .25), quantile(horas, .75))]
  ) /
  length(
    horas
  )
  ```

* [Metade]{.hl} do total de elementos está entre o primeiro e o terceiro quartis.

* Este é o chamado [intervalo interquartil]{.hl} (*interquartile range*, em inglês).

* No nosso vetor `horas`, os [limites do IQR]{.hl} são

  ```{r}
  quantile(horas, c(.25, .75))
  ```

* O [comprimento]{.hl} deste intervalo é calculado pela função `IQR`:

  ```{r}
  IQR(horas)
  ```

* Valores [muito abaixo do primeiro quartil]{.hl} podem ser considerados discrepantes (*outliers*), mas quão abaixo?

* A resposta (puramente convencional) é [$1{,}5 \times \text{IQR}$ abaixo do primeiro quartil.]{.hl}

* No nosso vetor `horas`, isto significa valores abaixo de

  ```{r}
  limite_inferior <- quantile(horas, .25) - 1.5 * IQR(horas)
  
  unname(limite_inferior)
  ```
  
* Neste caso, não há *outliers*:

  ```{r}
  horas[horas < limite_inferior]
  ```

* Da mesma forma, valores [muito acima do terceiro quartil]{.hl} podem ser considerados discrepantes (*outliers*), mas quão acima?

* De novo, a resposta (puramente convencional) é [$1{,}5 \times \text{IQR}$ acima do terceiro quartil.]{.hl}

* No nosso vetor `horas`, isto significa valores acima de

  ```{r}
  limite_superior <- quantile(horas, .75) + 1.5 * IQR(horas)
  
  unname(limite_superior)
  ```
  
* Neste caso, também não há *outliers*:

  ```{r}
  horas[horas > limite_superior]
  ```

* Outro exemplo: vamos tomar apenas os mamíferos onívoros:

  ```{r}
  onivoros <- sono %>% 
    filter(vore == 'omni')
  
  onivoros
  ```

* Vamos extrair o vetor de horas de sono:

  ```{r}
  horas <- onivoros %>% 
    pull(sleep_total)
  
  horas
  ```

* Vamos calcular o primeiro e terceiro quartis:

  ```{r}
  quartis <- horas %>% 
    quantile(c(.25, .75))
  
  quartis
  ```

* Vamos achar o IQR:

  ```{r}
  IQR(horas)
  ```

* E os limites a partir dos quais os valores são *outliers*:

  ```{r}
  limites <- quartis + c(-1, 1) * 1.5 * IQR(horas)
  
  unname(limites)
  ```

* Existem *outliers* inferiores?

  ```{r}
  onivoros %>% 
    filter(sleep_total < limites[1])
  ```

  Não.

* Existem *outliers* superiores?

  ```{r}
  onivoros %>% 
    filter(sleep_total > limites[2])
  ```

  Sim! Estes animais dormem demais em comparação com os outros onívoros. 


### Gerando boxplots

* Um *boxplot* é uma representação visual dos valores que calculamos acima.

* No `ggplot2`, a geometria `geom_boxplot` constrói *boxplots*:

  ```{r}
  sono %>% 
    ggplot(aes(y = sleep_total)) +
      geom_boxplot(fill = 'gray') +
      scale_x_continuous(breaks = NULL) +
      scale_y_continuous(breaks = seq(0, 20, 2))
  ```

* A [caixa]{.hl} vai do valor do [primeiro quartil]{.hl} (embaixo) até o [terceiro quartil]{.hl} (em cima).

* A [linha horizontal dentro da caixa]{.hl} representa o valor da [mediana]{.hl}.

* As [linhas verticais]{.hl} acima e abaixo da caixa (pitorescamente chamadas de "bigodes") vão até o [limite inferior]{.hl} (primeiro quartil ${}- 1{,}5 \times \text{IQR}$) e até o [limite superior]{.hl} (terceiro quartil ${}+ 1{,}5 \times \text{IQR}$).

* Neste *boxplot*, não há *outliers*.

* Podemos usar a posição $x$ para desenhar vários *boxplots*, um para cada dieta:

  ```{r}
  sono %>% 
    ggplot(aes(x = vore, y = sleep_total)) +
      geom_boxplot(fill = 'gray') +
      scale_y_continuous(breaks = seq(0, 20, 2))
  ```

* No *boxplot* de onívoros, [os *outliers* aparecem como pontos isolados,]{.hl} acima da caixa, além dos alcances do bigode superior (aliás, onde está bigode superior?).

* *Boxplots* lado a lado são úteis para compararmos grupos diferentes de dados.

* Veja como, com exceção dos insetívoros, as medianas dos grupos são parecidas.

* Veja como carnívoros, insetívoros e herbívoros apresentam maior variação, enquanto onívoros e animais sem dieta registrada apresentam menor variação.

* Vamos combinar, em um só gráfico

  * Os pontos representando os animais,
  
  * Os *boxplots*,
  
  * As médias (que podem estar próximas ou distantes das medianas).

  ```{r}
  sono %>% 
    ggplot(aes(x = vore, y = sleep_total)) +
      geom_boxplot(fill = 'gray') +
      scale_y_continuous(breaks = seq(0, 20, 2)) +
      geom_point(
        color = 'blue', 
        alpha = .3
      ) +
      stat_summary(
        fun = mean, 
        geom = 'point', 
        color = 'red', 
        shape = 'cross', 
        size = 5,
        stroke = 1
      ) +
      labs(
        title = 'Sono total de diversos mamíferos, por dieta',
        subtitle = '(o X vermelho representa a média)',
        x = 'dieta',
        y = 'sono total\n(em horas)'
      )
  ```

* [Quando a caixa é longa,]{.hl} o IQR é grande, e [os valores estão muito espalhados;]{.hl} é o caso dos herbívoros e insetívoros.

* [Quando a caixa é curta,]{.hl} o IQR é pequeno, e [os valores estão pouco espalhados]{.hl}; é o caso dos onívoros. Como o IQR é pequeno, os $4$ mamíferos com mais de $14$ horas de sono são *outliers*.

* Observe, ainda, como os *outliers* "puxam" a média dos onívoros para cima.


## Vídeo 2

```{r echo=FALSE, results='asis', out.extra=center()}
embed_yt('QqnOvgBXJ-s')
```


## Gráficos de barras e de colunas

### Dataset

```{r}
HairEyeColor
```

```{r}
df_orig <- as.data.frame(HairEyeColor) %>% 
  uncount(Freq) %>% 
  as_tibble()
```

```{r results='asis', message=FALSE}
df_orig %>% dfSummary() %>% print()
```

```{r}
cabelo <- c(
  'Brown' = 'Castanhos',
  'Blond' = 'Louros',
  'Black' = 'Pretos',
  'Red' = 'Ruivos'
)

olhos <- c(
  'Brown' = 'Castanhos',
  'Blue' = 'Azuis',
  'Hazel' = 'Avelã',
  'Green' = 'Verdes'
)

sexo <- c(
  'Male' = 'Homem',
  'Female' = 'Mulher'
)

df <- df_orig %>% 
  transmute(
    Cabelos = cabelo[Hair],
    Olhos = olhos[Eye],
    Sexo = sexo[Sex]
  )

```

```{r results='asis', message=FALSE}
df %>% dfSummary() %>% print()
```

```{r}
df %>% 
  ggplot(aes(x = Cabelos)) +
    geom_bar()
```

```{r}
df %>% 
  ggplot(aes(x = fct_rev(fct_infreq(Cabelos)))) +
    geom_bar()
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Sexo)) +
    geom_bar()
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Sexo)) +
    geom_bar() +
    scale_fill_discrete(type = c('blue', 'red'))
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Sexo)) +
    geom_bar() +
    scale_fill_discrete(type = c('blue', 'red')) +
    coord_flip()
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Sexo)) +
    geom_bar(position = 'dodge') +
    scale_fill_discrete(type = c('blue', 'red'))
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Olhos)) +
    geom_bar() +
    scale_fill_discrete(type = c('#908050', 'blue', 'brown', 'green'))
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Olhos)) +
    geom_bar(position = 'dodge') +
    scale_fill_discrete(type = c('#908050', 'blue', 'brown', 'green'))
```

```{r}
df %>% 
  ggplot(aes(x = fct_infreq(Cabelos), fill = Olhos)) +
    geom_bar(position = 'dodge') +
    scale_fill_discrete(type = c('#908050', 'blue', 'brown', 'green')) +
    facet_wrap(~Sexo) +
    labs(
      title = 'Cores de cabelos e olhos por sexo',
      y = NULL,
      x = 'Cabelos'
    )
```

```{r}
df %>% 
  ggplot(aes(x = Sexo, fill = fct_infreq(Olhos))) +
    geom_bar(position = 'dodge') +
    facet_wrap(~Cabelos, labeller = label_both) +
    scale_fill_discrete(type = c('brown', 'blue', '#908050', 'green')) +
    labs(
      x = NULL,
      y = NULL,
      fill = 'Olhos',
      title = 'Cor dos olhos e sexo por cor dos cabelos'
    )
```

### *Dataframe* já contendo os totais

```{r}
df_tot <- df %>% 
  count(Sexo, Cabelos, Olhos)

df_tot
```

```{r}
df_tot %>% 
  ggplot(aes(x = Cabelos, y = n)) +
    geom_col()
```

## Gráficos de linha e séries temporais

### Dataset

```{r}
WorldPhones
```

```{r}
fones <- WorldPhones %>% 
  as_tibble(rownames = 'Ano') %>% 
  mutate(Ano = as.numeric(Ano))

fones
```

```{r}
fones_long <- fones %>% 
  pivot_longer(
    cols = -Ano,
    names_to = 'Região',
    values_to = 'n'
  )

fones_long
```

```{r}
fones_long %>% 
  ggplot(aes(x = Ano, y = n, group = Região, color = Região)) +
    geom_line() +
    scale_x_continuous(breaks = 1951:1961)
```

```{r}
fones_long %>% 
  ggplot(
      aes(
        x = Ano, 
        y = n, 
        group = Região, 
        color = fct_rev(fct_reorder(Região, n))
      )
  ) +
    geom_line() +
    scale_x_continuous(breaks = 1951:1961) +
    labs(
      color = 'Região',
      y = '',
      x = NULL,
      title = 'Quantidade de aparelhos de telefone por ano, por região'
    )
```

```{r}
fones_long %>%
  filter(Região %in% c('S.Amer', 'Oceania')) %>% 
  ggplot(aes(x = Ano, y = n, group = Região, color = Região)) +
    geom_line() +
    scale_x_continuous(breaks = 1951:1961)
```

```{r eval=FALSE}
library(tsibble)
?`tsibble-package`
```

## Referências sobre visualização e R

::: {.rmdtip latex=1}

Busque mais informações sobre os pacotes `tidyverse` e `ggplot2` [nas referências recomendadas](#refrec).

:::
