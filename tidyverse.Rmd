--- 
knit: "bookdown::render_book"
---

# Introdução ao `tidyverse`

::: {.rmdtip latex=1}

Busque mais informações sobre os pacotes que compõem o `tidyverse` [nas referências recomendadas](#refrec).

:::


## Criando uma *tibble*

* Uma *tibble* é uma tabela retangular.

* [Cada coluna é um vetor]{.hl}:

  ```{r}
  cores <- tibble(
    pessoa = c('João', 'Maria', 'Pedro', 'Ana'),
    'cor favorita' = c('azul', 'rosa', 'preto', 'branco')
  )
  
  cores
  ```

* Isto é um pouco diferente da maneira como estamos acostumados a ver tabelas (como uma coleção de linhas, em vez de uma coleção de colunas).

* A função `tribble` permite a entrada de forma mais natural, linha a linha. [Lembre-se de usar `~` antes dos nomes das colunas.]{.hl}

  ```{r}
  cores <- tribble(
    ~pessoa, ~'cor favorita',
     "João",          "azul",
    "Maria",          "rosa",
    "Pedro",         "preto",
      "Ana",        "branco"
  )
  
  cores
  ```

  ::: {.rmdcaution latex=1}
  
  Mesmo que você crie uma *tibble* linha a linha, o R vai continuar tratando sua *tibble* como uma coleção de colunas.
  
  É importante lembrar disto para entender a forma como R manipula estas tabelas.
  
  :::

* Se uma coluna não puder ser armazenada em um vetor, a coluna será uma lista (com vetores como elementos):

  ```{r}
  cores <- tibble(
    pessoa = c('João', 'Maria', 'Pedro', 'Ana'),
    'cor favorita' = list(
      c('azul', 'roxo'),
      c('rosa', 'magenta'),
      NA,
      'branco'
    )
  )
  
  cores
  ```

* Use `View()` para examinar interativamente o conteúdo de uma coluna-lista:

  ```{r eval=FALSE}
  cores %>% View()
  ```

## Operador de *pipe* (`%>%`)

* O `tidyverse` inclui o pacote `magrittr`, que contém o operador `%>%`, chamado *pipe*.[^trocadilho]

[^trocadilho]: Por que o nome do pacote e o nome do operador formam um trocadilho?

* A idéia é facilitar a leitura de [composições de funções]{.hl}. O código

  ```{r eval=FALSE}
  y <- h(g(f(x)))
  ```

  pode ser escrito como
  
  ```{r eval=FALSE}
  y <- x %>% f() %>% g() %>% h()
  ```

* Esta segunda versão é mais fiel à ordem em que as operações acontecem.

* Na verdade, R tem um operador de [atribuição para a direita]{.hl}, mas poucas pessoas recomendam usá-lo:

  ```{r eval=FALSE}
  x %>% f() %>% g() %>% h() -> y
  ```

* Se `f`, `g` e `h` forem funções de um argumento só, os parênteses podem ser omitidos:

  ```{r eval=FALSE}
  y <- x %>% f %>% g %>% h
  ```

* Se a função `f` tiver outros argumentos, escreva-os normalmente na chamada a `f`:

  ```{r eval=FALSE}
  y <- x %>% mean(na.rm = TRUE)
  ```

* O *pipe* `EXP %>% f(...)` sempre insere o resultado da expressão `EXP` como o [primeiro argumento da função `f`]{.hl}.

* Se você precisar que o resultado da expressão `EXP` seja inserido em outra posição na lista de argumentos de `f`, use um ponto "`.`" para isso:

  ```{r eval=FALSE}
  x %>% consultar(df, .)
  ```
  
  equivale a

  ```{r eval=FALSE}
  consultar(df, x)
  ```
  

## Formato *tidy*

* Nossa última versão da *tibble* `cores` é um pouco mais complexa do que deveria ser:

  ```{r}
  cores
  ```

* O formato *tidy* exige que 

  1. [Cada linha]{.hl} da *tibble* corresponda a uma [observação]{.hl} sobre um indivíduo,
  
  1. [Cada coluna]{.hl} corresponda a [uma variável observada]{.hl}, e
  
  1. [Cada célula]{.hl} contenha [um valor]{.hl} da variável.
  
* Na *tibble* `cores`, a primeira e a segunda exigências são satisfeitas, mas a terceira não, pois algumas células contém valores múltiplos.

* A *tibble* não está no formato *tidy*.

* Podemos "extrair" estes vetores "aninhados" usando o comando `unnest`, do pacote `tidyr`:

  ```{r}
  cores <- cores %>% 
    unnest(`cor favorita`)
  
  cores
  ```

* [A maioria das funções do `tidyverse` exige que as *tibbles* estejam neste formato *tidy*.]{.hl}

* Um exemplo mais complexo é o *dataset* `billboard`, com as seguintes colunas (para cada música que estava no *top 100* da Billboard no ano de $2000$):

  * Nome do artista ou banda;
  
  * Nome da música;
  
  * Data em que a música entrou no *top 100* da Billboard;
  
  * Para cada uma das $76$ semanas seguintes, a posição da música no *top 100*.

  ```{r}
  billboard %>% glimpse()
  ```

* Vamos renomear as colunas:

  ```{r}
  bb <- billboard %>% 
    rename(
      artista = artist,
      musica = track,
      entrou = date.entered
    )
  ```

  ```{r}
  bb %>% head()
  ```

* [O que é uma observação]{.hl} neste conjunto de dados?

  [A posição, em uma semana, de uma música]{.hl} que esteve no *top* $100$ da *Billboard* durante o ano *2000*.
  
* [Quais são as variáveis]{.hl} que qualificam cada observação?

  * O artista,
  
  * O título da música,
  
  * A posiçao da música no *top* $100$ da *Billboard* em cada uma das $76$ semanas depois que ela entrou na lista.
  
* Este último item é complexo, e o criador da *tibble* decidiu criar uma coluna por semana.

* [Uma decisão ruim, pois existe informação embutida nos nomes das colunas.]{.hl} A coluna `wk68` corresponde à posição da música na semana $68$ após ela entrar na lista, [mas o número da semana só aparece no nome da coluna]{.hl}!

* Isto [nunca]{.hl} deve acontecer. [A informação deve sempre estar nas células.]{.hl}

* Vamos simplificar as coisas criando duas colunas:

  * `semana`, com o número da semana; perceba que esta informação vem dos nomes das colunas,
  
  * `pos`, com a posição da música naquela semana; esta informação vem das células.
  
* A *tibble*, que antes era larga, [vai ser mais estreita e mais longa]{.hl}.

* A função `pivot_longer`, do pacote `tidyr`, vai fazer o trabalho --- inclusive extraindo os números das semanas dos nomes das colunas:

  ```{r}
  bb_tidy <- bb %>% 
    pivot_longer(
      wk1:wk76,
      names_to = 'semana',
      names_prefix = 'wk',
      names_transform = list(
        semana = as.integer
      ),
      values_to = 'pos'
    )
  
  bb_tidy
  ```

* O R só mostra, por *default*, as $1000$ primeiras linhas de uma *tibble*.

* Na verdade, o número de linhas da tabela original era

  ```{r}
  bb %>% nrow()
  ```

* O número de linhas, depois de `pivot_longer`, ficou:

  ```{r}
  bb_tidy %>% nrow()
  ```

* Existem linhas onde `pos` tem o valor `NA`. São resultado da organização original dos dados, onde o `NA` indicava que a música não estava no *top* $100$ naquela semana.

* No novo formato, a ausência da linha com aquele número de semana já basta para indicar isto. Então, vamos eliminar as linhas onde `pos` é `NA`.

* A função `filter` [mantém]{.hl} as linhas que [satisfazem]{.hl} a condição dada; por isso, a condição é "`pos` não é `NA`":

  ```{r}
  bb_tidy <- bb_tidy %>% 
    filter(!is.na(pos))
  
  bb_tidy
  ```

* O número de linhas ficou  

  ```{r}
  bb_tidy %>% nrow()
  ```


### Exercícios

* Todas as semanas deste conjunto de dados são do ano $2000$?

* Qual é o tipo do [primeiro]{.hl} argumento da função `filter()`?


## Manipulando os dados

### Criando novas colunas: `mutate`, `transmute`

* O *data frame*^[Considere *data frame* como sinônimo de *tibble*. Na verdade, *tibbles* formam um superconjunto de *data frames*: todo *data frame* é uma *tibble*, mas nem toda *tibble* é um *data frame*.] `cars` tem dados (de $1920$!) sobre as distâncias de frenagem (em pés) de um carro viajando a diversas velocidades (em milhas por hora):

  ```{r}
  cars
  ```

* Vamos criar colunas novas com os valores convertidos para km/h e metros; além disso, uma coluna com a taxa de frenagem:

  ```{r}
  cars %>% 
    mutate(
      velocidade = speed * 1.6,
      distancia = dist * .33,
      taxa = velocidade / distancia
    )
  ```

* Perceba que as colunas antigas continuam lá. [Se quiser manter apenas as colunas novas, use `transmute`]{.hl}:

  ```{r}
  cars %>% 
    transmute(
      velocidade = speed * 1.6,
      distancia = dist * .33,
      taxa = velocidade / distancia
    )
  ```

* Ou use o argumento `.keep` de `mutate` para escolher com mais precisão. Veja a ajuda de `mutate`.


### Selecionando colunas: `select`, `distinct`, `pull`

* Vamos voltar à nossa *tibble* dos *top* $100$ da *Billboard*.

* Para ver só a coluna de artistas:

  ```{r}
  bb_tidy %>% 
    select(artista)
  ```

* Para eliminar as repetições:

  ```{r}
  bb_tidy %>% 
    select(artista) %>% 
    distinct()
  ```

* Para ver artistas e músicas:

  ```{r}
  bb_tidy %>% 
    select(artista, musica) %>% 
    distinct()
  ```

* Para especificar colunas [a não mostrar]{.hl}, use o sinal de menos "`-`":

  ```{r}
  bb_tidy %>% 
    select(-c(entrou, semana, pos))
  ```

* Para [extrair uma coluna na forma de vetor]{.hl} (`unique` é uma função do R base, aplicável a vetores):

  ```{r}
  bb_tidy %>% 
    pull(artista) %>% 
    unique()
  ```


### Filtrando linhas: `filter`, `slice`

* Apenas as músicas da Britney Spears:

  ```{r}
  bb_tidy %>% 
    filter(artista == 'Spears, Britney')
  ```

* Apenas músicas que chegaram à posição $1$, sem mostrar a coluna `pos`:

  ```{r}
  bb_tidy %>% 
    filter(pos == 1) %>% 
    select(-pos)
  ```

* Apenas músicas que chegaram à posição $1$ em menos de $10$ semanas, mostrando apenas artista e música:

  ```{r}
  bb_tidy %>% 
    filter(pos == 1, semana < 10) %>% 
    distinct(artista, musica)
  ```

* As funções da família `slice` filtram linhas de diversas maneiras.

* De acordo com seus índices (números de linha):

  ```{r}
  bb_tidy %>% 
    slice(c(1, 1000, 5000))
  ```

  ```{r}
  bb_tidy %>% 
    slice_head(n = 4)
  ```

  ```{r}
  bb_tidy %>% 
    slice_tail(n = 4)
  ```

* De acordo com a [ordenação de uma coluna]{.hl} ou [de uma função das colunas]{.hl}:
  
  ```{r}
  bb_tidy %>% 
    slice_min(pos)
  ```

  ```{r}
  bb_tidy %>% 
    slice_max(semana)
  ```

* Aleatoriamente, criando uma amostra:
  
  ```{r}
  bb_tidy %>% 
    slice_sample(n = 5)
  ```
  
* Veja a ajuda de `slice` para saber mais sobre estas funções. Por exemplo: 

  * `slice_min` e `slice_max` podem considerar ou não empates.
  
  * Você pode especificar uma proporção de linhas (usando `prop`) em vez da quantidade de linhas (`n`).
  
  * Você pode fazer amostragem com reposição, ou com probabilidades diferentes para cada linha.


### Ordenando linhas: `arrange`

* Por título, sem repetições:

  ```{r}
  bb_tidy %>% 
    select(musica) %>% 
    distinct() %>% 
    arrange(musica)
  ```

* Por título, sem repetições, em ordem inversa:

  ```{r}
  bb_tidy %>% 
    select(musica) %>% 
    distinct() %>% 
    arrange(desc(musica))
  ```


### Contando linhas: `count`

* Quantas semanas cada artista ficou nos *top* $100$? Duas músicas na mesma semana contam como duas semanas.

  ```{r}
  bb_tidy %>% 
    count(artista, sort = TRUE)
  ```

* Quantas semanas cada música ficou nos *top* $100$?

  ```{r}
  bb_tidy %>% 
    count(musica, sort = TRUE)
  ```

* Se houve músicas com o mesmo nome, mas de artistas diferentes, [o código acima está errado]{.hl}. O certo é

  ```{r}
  bb_tidy %>% 
    count(musica, artista, sort = TRUE)
  ```

  De fato, há uma diferença de uma linha.
  
  
#### Exercício

* Ache o título da música que tem dois artistas diferentes. 

  **Sugestão:** conte por música e artista primeiro, depois só por música.


### Agrupando linhas: `group_by` e `summarize`

* Qual foi a melhor posição que cada artista alcançou?

  ```{r}
  bb_tidy %>% 
    group_by(artista) %>% 
    summarize(melhor = min(pos)) %>% 
    arrange(melhor)
  ```

* Qual foi a melhor posição que cada música alcançou?

  ```{r}
  bb_tidy %>% 
    group_by(artista, musica) %>% 
    summarize(melhor = min(pos)) %>% 
    arrange(melhor)
  ```

* Quando usamos `summarize`, só o agrupamento [mais interno]{.hl} é desfeito. Isto significa que [o resultado acima ainda está agrupado por `artista`]{.hl}.

* Quantas semanas cada artista ficou na posição $1$? 

  A função `n()` é uma maneira conveniente de [obter o número de linhas de um grupo]{.hl} (ou, se não houver agrupamento, de toda a *tibble*); mas [`n()` só pode ser chamada em certos contextos]{.hl}, como `summarise()` ou `mutate()`.

  ```{r}
  bb_tidy %>% 
    filter(pos == 1) %>% 
    group_by(artista) %>%
    summarize(semanas = n()) %>% 
    arrange(desc(semanas))
  ```

* Perceba que `count`, que vimos mais acima, faz agrupamentos do mesmo modo:

  ```{r}
  bb_tidy %>% 
    filter(pos == 1) %>% 
    count(artista, sort = TRUE)
  ```

* Uma pergunta diferente: quais são os artistas cujas músicas apareceram no *top* $100$ mais tempo depois do lançamento da música?

  ```{r}
  bb_tidy %>% 
    group_by(artista) %>% 
    summarize(semanas = max(semana)) %>% 
    arrange(desc(semanas))
  ```


* Qual a posição média de cada música? Lembre-se de que eliminamos as linhas com `NA`; logo, [a média vai ser sobre a quantidade de semanas em que a música esteve na lista]{.hl}.

  ```{r}
  media1 <- bb_tidy %>% 
    group_by(artista, musica) %>% 
    summarize(media = mean(pos), .groups = 'drop') %>% 
    arrange(media)
  
  media1
  ```

* E se quisermos [a média sobre o número de semanas desde a entrada da música até a última semana]{.hl} em que a música apareceu na lista?

  ```{r}
  media2 <- bb_tidy %>% 
    group_by(artista, musica) %>% 
    summarize(media = sum(pos)/max(semana), .groups = 'drop') %>% 
    arrange(media)
  
  media2
  ```

  As primeiras linhas são iguais, mas os resultados são diferentes:

  ```{r}
  identical(media1, media2)
  ```

## Exercícios

1. Vamos trabalhar com um conjunto de dados sobre super-heróis.

   Execute o seguinte comando para ler os dados para uma *tibble*:

    ```{r messages=FALSE}
    # read_csv('https://github.com/fnaufel/probestr/raw/master/data/CEO_Salary_2012.csv')
    herois_info <- read_csv(
      'data/heroes_information.csv',
      na = c('', '-', 'NA')
    ) %>% 
      # Eliminar a primeira coluna (números de série)
      select(-1) %>% 
      # Renomear colunas restantes
      rename(
        nome = name,
        sexo = Gender,
        olhos = 'Eye color',
        raça = Race,
        cabelos = 'Hair color',
        altura = Height,
        editora = Publisher,
        pele = 'Skin color',
        lado = Alignment,
        peso = Weight
      )
    ```

1. Quantas editoras diferentes existem na *tibble*? Liste-as em ordem decrescente de quantidade de heróis.

1. Na coluna `editora`, substitua 

   * 'Marvel Comics' por 'Marvel', 
   * 'DC Comics' por 'DC', e 
   * todas as outras editoras pelo termo 'Outras'.
   
   **Dica:** use a função `case_when()`, do `tidyverse`.
   
1. Confira, novamente, a quantidade de valores diferentes na coluna `editora`.

1. Existem heróis sem informação de editora. Quantos? Quais são?

1. Altere novamente a coluna `editora`, colocando o valor 'Outras' para os heróis sem informação de editora. Use a função `if_else()` (com *underscore*, não a função `ifelse`).

1. Confira, mais uma vez, a quantidade de valores diferentes na coluna `editora`.

1. Existem heróis sem informação de sexo? Quantos? Para estes heróis, coloque o valor 'Desconhecido' na coluna `sexo`.

1. Qual a altura mínima? Qual a altura máxima? Substitua as alturas negativas por `NA`.

1. Qual o peso mínimo? Qual o peso máximo? Substitua os pesos negativos por `NA`.

1. Qual é o peso médio de todos os heróis? Ignore os valores `NA`.

1. Qual é a altura média de todos os heróis? Ignore os valores `NA`.

1. Qual é a altura média dos heróis, por editora? Ignore os valores `NA`.

1. Quais são os $3$ heróis mais altos de cada sexo?

1. Quais são as $3$ cores de olhos mais comuns para cada sexo?

1. Liste, por editora, as quantidades de heróis do bem, do mal, e neutros.

1. Quantas raças diferentes existem?

1. Qual a quantidade de raças diferentes de cada editora?

1. **DESAFIO:** Liste as raças que só pertencem a uma única editora.

   Existem várias maneiras de fazer isto. Experimente várias, até achar uma que seja mais elegante.
